getwd()
read.csv("hw1_data.csv")
prova1<-read.csv("hw1_data.csv")
View(prova1)
View(prova1)
names(prova1)
prova1[2,]
prova1[3,]
prova1[1:2,]
nrows(prova1)
nrow(prova1)
prova1[152:153,]
prova1[47,1]
bad <- is.na(prova1)
bad
x[bad]
missing<-prova1[bad]
missing
ozone <- prova1[,1]
ozone
bad <- is.na(ozone)
bad
missing<-ozone[bad]
missing
length(missing)
good <- ozone[!bad]
good
mean(good)
ozonemagg <- prova1("ozone">31)
ozonemagg <- prova1["ozone">31]
ozonemagg
clear ozone
a<-na
a<-"na"
a<-"NA"
a
a<-NA
a
ozone1=prova1[1,]
ozone1
ozone1=prova1[,1]
ozone1
ozone1[ozone1<=31]<-0
ozone1
temp1=prova1[,4]
temp1
temp1[temp1<=90]<-0
temp1
ozone2<-ozone1
ozone2[ozone2==NA]<-0
ozone2
provaozone <- ozone1>31
provaozone
ozone1=prova1[,1]
ozone1
provaozone <- ozone1>31
provaozone
temp1=prova1[,4]
provatemp <- temp1>90
provaozonetemp <- prova1[provaozone || provatemp]
provaozonetemp
provaozone*provatemp
provaozone*provatemp*prova1[,2]
mean(provaozone*provatemp*prova1[,2])
a<-provaozone*provatemp*prova1[,2]
b<-a[>0]
b<-a[a>0]
b
bad<-is.na(b)
c<-b[!bad]
c
mean(c)
setwd("C:/ILLY/Coursera/DS2-Rprogramming/Quiz3/ProgrammingAssignment2")
m <- matrix(NULL, 2,2)
m <- matrix(2,2)
m
m <- matrix(,2,2)
m
m <- matrix(data=NULL,2,2)
x <- matrix(,2,2)
x
inv <‐ matrix(,nrow=dim(x,1),ncol=dim(x,2))
inv <‐ matrix(,nrow=dim(x)[1],ncol=dim(x)[2])
inv
makeCacheMatrix <- function(x = matrix()) {
inv <‐ matrix(,nrow=dim(x)[1],ncol=dim(x)[2])   ## CREA UNA MATRICE inv NEL CURRENT ENVIRONMENT
## (CON VALORI NA E CON LE STESSE DIMENSIONI DI X)...
## A COSA SERVE QUESTA RIGA?
set <‐ function(y) { ## SET THE VALUE OF THE MATRIX; CACHE LOCATION
x <<‐ y  ## CREA UNA COPIA X DELLA MATRICE Y; X SI TROVA NELLA CACHE
inv <<‐ matrix(,nrow=dim(y)[1],ncol=dim(y)[2]) ## CREA UNA MATRICE inv NELLA CACHE, VUOTA
}
get <‐ function() x ## GET THE VALUE OF THE MATRIx
m
setinv <‐ function(solve) inv <<‐ solve ## SET THE VALUE OF THE INVERSE; CACHE LOCATION
getinv <‐ function() inv  ## GET THE VALUE OF THE INVERSE
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
rm(inv)
rm(x,m)
m <- matrix(1:4,2,2)
m
makeCacheMatrix(m)
makeCacheMatrix <- function(x = matrix()) {
inv <‐ matrix(,nrow=dim(x)[1],ncol=dim(x)[2])   ## CREA UNA MATRICE inv NEL CURRENT ENVIRONMENT
## (CON VALORI NA E CON LE STESSE DIMENSIONI DI X)...
## A COSA SERVE QUESTA RIGA?
set <‐ function(y) { ## SET THE VALUE OF THE MATRIX; CACHE LOCATION
x <<‐ y  ## CREA UNA COPIA X DELLA MATRICE Y; X SI TROVA NELLA CACHE
inv <<‐ matrix(,nrow=dim(y)[1],ncol=dim(y)[2]) ## CREA UNA MATRICE inv NELLA CACHE, VUOTA
}
get <‐ function() x ## GET THE VALUE OF THE MATRIx
m
setinv <‐ function(solve) inv <<‐ solve ## SET THE VALUE OF THE INVERSE; CACHE LOCATION
getinv <‐ function() inv  ## GET THE VALUE OF THE INVERSE
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
makeCacheMatrix <- function(x = matrix()) {
inv <‐ matrix(,nrow=dim(x)[1],ncol=dim(x)[2])   ## CREA UNA MATRICE inv NEL CURRENT ENVIRONMENT
## (CON VALORI NA E CON LE STESSE DIMENSIONI DI X)...
## A COSA SERVE QUESTA RIGA?
set <‐ function(y) { ## SET THE VALUE OF THE MATRIX; CACHE LOCATION
x <<‐ y  ## CREA UNA COPIA X DELLA MATRICE Y; X SI TROVA NELLA CACHE
inv <<‐ matrix(,nrow=dim(y)[1],ncol=dim(y)[2]) ## CREA UNA MATRICE inv NELLA CACHE, VUOTA
}
get <‐ function() x ## GET THE VALUE OF THE MATRIx
m
setinv <‐ function(solve) inv <<‐ solve ## SET THE VALUE OF THE INVERSE; CACHE LOCATION
getinv <‐ function() inv  ## GET THE VALUE OF THE INVERSE
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
makeCacheMatrix <- function(x = matrix()) {
inv <‐ matrix(,nrow=dim(x)[1],ncol=dim(x)[2])   ## CREA UNA MATRICE inv NEL CURRENT ENVIRONMENT
## (CON VALORI NA E CON LE STESSE DIMENSIONI DI X)...
## A COSA SERVE QUESTA RIGA?
set <‐ function(y) { ## SET THE VALUE OF THE MATRIX; CACHE LOCATION
x <<‐ y  ## CREA UNA COPIA X DELLA MATRICE Y; X SI TROVA NELLA CACHE
inv <<‐ matrix(,nrow=dim(y)[1],ncol=dim(y)[2]) ## CREA UNA MATRICE inv NELLA CACHE, VUOTA
}
get <‐ function() x ## GET THE VALUE OF THE MATRIx
m
setinv <‐ function(solve) inv <<‐ solve ## SET THE VALUE OF THE INVERSE; CACHE LOCATION
getinv <‐ function() inv  ## GET THE VALUE OF THE INVERSE
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
return(inv)
}
makeCacheMatrix(m)
rm
rm(makeCacheMatrix)
solve(m)
makeVector <‐ function(x = numeric()) {
m <‐ NULL
set <‐ function(y) {
x <<‐ y
m <<‐ NULL
}
get <‐ function() x
setmean <‐ function(mean) m <<‐ mean
getmean <‐ function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
a = c(1,2,3,4)
makeVector(a)
makeVector <‐ function(x = numeric()) {
m <‐ NULL
set <‐ function(y) {
x <<‐ y
m <<‐ NULL
}
get <‐ function() x
setmean <‐ function(mean) m <<‐ mean
getmean <‐ function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
return(m)
}
makeVector(a)
makeVector <‐ function(x = numeric()) {
m <‐ NULL
set <‐ function(y) {
x <‐ y
m <‐ NULL
}
get <‐ function() x
setmean <‐ function(mean) m <‐ mean
getmean <‐ function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
return(m)
}
makeVector(a)
rm(makeVector)
makeVector <‐ function(x = numeric()) {
m <‐ NULL
set <‐ function(y) {
x <‐ y
m <‐ NULL
}
get <‐ function() x
setmean <‐ function(mean) m <‐ mean
getmean <‐ function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <‐ function(x, ...) {
m <‐ x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <‐ x$get()
m <‐ mean(data, ...)
x$setmean(m)
m
}
cachemean(a)
